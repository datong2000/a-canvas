import { XY } from './utils/utils';
import { WheelEvent } from './utils/event';
import { RingType } from './utils/direction';
import Matrix from './Matrix';
import Tag from './a';
import Vector from './vector';
import Outline from './outline';
interface TagCanvasType {
    id: string;
    tagId: string;
    opt: object;
}
interface RotateTagType {
    active: boolean;
    callback: (ACanvas?: ACanvas, Tag?: Tag) => void;
    id?: string;
    tag?: Tag;
    lat?: number;
    lng?: number;
    time: number;
}
interface fixedAnimType {
    tag: Tag;
    t?: number;
    cb?: (ACanvas?: ACanvas, Tag?: Tag) => void;
    active?: boolean;
    angle?: number;
    axis?: Vector;
    t0?: number;
    transform?: Matrix | undefined;
    type?: number;
}
interface NewableFunction extends Function {
    sphere?: ({ n, xr, yr, zr, m }: RingType) => number[][];
    vcylinder?: ({ n, xr, yr, zr, m }: RingType) => number[][];
    hcylinder?: ({ n, xr, yr, zr, m }: RingType) => number[][];
    vring?: ({ n, xr, yr, zr, j }: RingType) => number[][];
    hring?: ({ n, xr, yr, zr, j }: RingType) => number[][];
}
declare type HandleMouseEvent = (e: MouseEvent) => void;
declare type HandleTouchEvent = (e: TouchEvent) => void;
declare type HandleWheelEvent = (e: WheelEvent) => void;
export default class ACanvas {
    offsetX: number;
    offsetY: number;
    zoomMin: number;
    zoomMax: number;
    frontSelect: string;
    zoomStep: number;
    wheelZoom: boolean;
    dragThreshold: number;
    textColour: string;
    textFont: string;
    textHeight: number;
    minBrightness: number;
    maxBrightness: number;
    stretchX: number;
    stretchY: number;
    z1: number;
    z2: number;
    z0: number;
    lock: string;
    dragControl: boolean;
    hideTags: boolean;
    interval: number;
    reverse: boolean;
    maxSpeed: number;
    minSpeed: number;
    radiusX: number;
    radiusY: number;
    radiusZ: number;
    zoom: number;
    initial: number[];
    shape: string | NewableFunction;
    depth: number;
    ctxt: CanvasRenderingContext2D;
    max_radius: number;
    radius: number;
    mx: number;
    my: number;
    canvas: HTMLCanvasElement;
    lx: number;
    ly: number;
    frozen: number;
    dx: number;
    dy: number;
    fixedAnim: fixedAnimType;
    touchState: number;
    fixedAlpha: number;
    source: string;
    transform: Matrix;
    Animate: (w: number, h: number, t: number) => void;
    animTiming: (t: number, t0: number) => number;
    started: number;
    yaw: number;
    pitch: number;
    shapeArgs: RingType;
    taglist: Tag[];
    listLength: number;
    freezeDecel: boolean;
    freezeActive: boolean;
    activeCursor: string;
    decel: number;
    fixedCallbackTag: Tag;
    fixedCallback: (ACanvas?: ACanvas, Tag?: Tag) => void | null;
    preFreeze: number[];
    drawn: number | boolean;
    active: Outline | null;
    time: number;
    down: XY;
    dragging: number | null;
    pinched: number[];
    static ac: {
        [key: string]: ACanvas;
    };
    static handlers: {
        [key: string]: Array<[string, HandleMouseEvent | HandleTouchEvent | HandleWheelEvent]>;
    };
    static options: {
        z1: number;
        z2: number;
        z0: number;
        freezeActive: boolean;
        freezeDecel: boolean;
        activeCursor: string;
        reverse: boolean;
        depth: number;
        maxSpeed: number;
        minSpeed: number;
        decel: number;
        interval: number;
        minBrightness: number;
        maxBrightness: number;
        textColour: string;
        textHeight: number;
        textFont: string;
        initial: any;
        hideTags: boolean;
        frontSelect: boolean;
        zoom: number;
        wheelZoom: boolean;
        zoomMin: number;
        zoomMax: number;
        zoomStep: number;
        shape: string;
        lock: any;
        radiusX: number;
        radiusY: number;
        radiusZ: number;
        stretchX: number;
        stretchY: number;
        offsetX: number;
        offsetY: number;
        dragControl: boolean;
        dragThreshold: number;
    };
    static interval: number;
    static nextFrame: (interval: number) => void;
    static start(id: TagCanvasType['id'], tagId: TagCanvasType['tagId'], opt: TagCanvasType['opt']): void;
    static delete(id: string): void;
    static reload(id: string): void;
    static update(id: string): void;
    static setSpeed(id: string, speed: number[]): boolean;
    static tagToFront(id: string, options: RotateTagType): boolean;
    static rotateTag(id: string, options: RotateTagType): boolean;
    static drawCanvasRAF(time: number): void;
    NextFrameRAF(): void;
    constructor(v: TagCanvasType);
    HideTags(): void;
    GetTags(): Element[];
    CreateTag(a: HTMLAnchorElement): Tag;
    Draw(t?: number): void;
    Transform(p: number, y: number): void;
    AnimateFixed(): boolean;
    AnimatePosition(w: number, h: number, t: number): void;
    AnimateDrag(_w: number, _h: number, t: number): void;
    Freeze(): void;
    UnFreeze(): void;
    Decel(ac: ACanvas): void;
    Zoom(r: number): void;
    Clicked(): void;
    Wheel(i: boolean): void;
    BeginDrag(e: MouseEvent | TouchEvent): void;
    Drag(p: XY): number;
    EndDrag(): number;
    PinchDistance(e: TouchEvent): number;
    BeginPinch(e: TouchEvent): void;
    Pinch(e: TouchEvent): void;
    EndPinch(): void;
    SetSpeed(i: number[]): void;
    FindTag(t: RotateTagType): Tag;
    RotateTag({ tag, lat, lng, time, callback, active }: RotateTagType): void;
    Load(): void;
    Update(): void;
    Smooth(t: number, t0: number): number;
}
export {};
