import { XY } from './utils/utils';
import { WheelEvent } from './utils/event';
import { RingType } from './utils/direction';
import Matrix from './Matrix';
import A from './a';
import Vector from './vector';
import Outline from './outline';
interface ACanvasType {
    id: string;
    AElement: string;
    opt: object;
}
interface RotateTagType {
    callback?: (ACanvas?: ACanvas, A?: A) => void;
    id?: string;
    a?: A;
    lat?: number;
    lng?: number;
    time: number;
}
interface fixedAnimType {
    a: A;
    t?: number;
    cb?: (ACanvas?: ACanvas, A?: A) => void;
    angle?: number;
    axis?: Vector;
    t0?: number;
    transform?: Matrix | undefined;
    type?: number;
}
interface NewableFunction extends Function {
    sphere?: ({ n, xr, yr, zr }: RingType) => number[][];
    vcylinder?: ({ n, xr, yr, zr }: RingType) => number[][];
    hcylinder?: ({ n, xr, yr, zr }: RingType) => number[][];
    vring?: ({ n, xr, yr, zr }: RingType) => number[][];
    hring?: ({ n, xr, yr, zr }: RingType) => number[][];
}
export declare type EventType = (e: MouseEvent & TouchEvent & WheelEvent & Event) => void;
declare type HandleEvents = [string, EventType];
export default class ACanvas {
    offsetX: number;
    offsetY: number;
    zoomMin: number;
    zoomMax: number;
    frontSelect: boolean;
    zoomStep: number;
    wheelZoom: boolean;
    dragThreshold: number;
    textColour: string;
    textFontStyle: string;
    textHeight: number;
    textFontFamily: string;
    minBrightness: number;
    maxBrightness: number;
    stretchX: number;
    stretchY: number;
    z1: number;
    z2: number;
    z0: number;
    lock: string;
    dragControl: boolean;
    hideElement: boolean;
    interval: number;
    reverse: boolean;
    maxSpeed: number;
    minSpeed: number;
    radiusX: number;
    radiusY: number;
    radiusZ: number;
    zoom: number;
    initial: number[];
    shape: string | NewableFunction;
    depth: number;
    ctxt: CanvasRenderingContext2D;
    max_radius: number;
    radius: number;
    mx: number;
    my: number;
    canvas: HTMLCanvasElement;
    lx: number;
    ly: number;
    frozen: number;
    dx: number;
    dy: number;
    fixedAnim: fixedAnimType;
    touchState: number;
    fixedAlpha: number;
    source: string;
    transform: Matrix;
    Animate: (w: number, h: number, t: number) => void;
    animTiming: (t: number, t0: number) => number;
    started: number;
    yaw: number;
    pitch: number;
    shapeArgs: RingType;
    aList: A[];
    listLength: number;
    freezeDecel: boolean;
    freezeActive: boolean;
    activeCursor: string;
    decel: number;
    fixedCallbackTag: A;
    fixedCallback: (ACanvas?: ACanvas, A?: A) => void | null;
    preFreeze: number[];
    drawn: number | boolean;
    active: Outline | null;
    time: number;
    down: XY;
    dragging: number | null;
    pinched: number[];
    static ac: {
        [key: string]: ACanvas;
    };
    static handlers: {
        [key: string]: Array<HandleEvents>;
    };
    static options: {
        z1: number;
        z2: number;
        z0: number;
        freezeActive: boolean;
        freezeDecel: boolean;
        activeCursor: string;
        interval: number;
        minBrightness: number;
        maxBrightness: number;
        textColour: string;
        textFontStyle: string;
        textHeight: number;
        textFontFamily: string;
        initial: any;
        hideElement: boolean;
        frontSelect: boolean;
        zoom: number;
        wheelZoom: boolean;
        zoomMin: number;
        zoomMax: number;
        zoomStep: number;
        shape: string;
        lock: any;
        radiusX: number;
        radiusY: number;
        radiusZ: number;
        stretchX: number;
        stretchY: number;
        offsetX: number;
        offsetY: number;
        dragControl: boolean;
        dragThreshold: number;
        reverse: boolean;
        depth: number;
        maxSpeed: number;
        minSpeed: number;
        decel: number;
    };
    static nextFrame: (interval: number) => void;
    static start(id: ACanvasType['id'], AElement: ACanvasType['AElement'], opt: ACanvasType['opt']): void;
    static delete(id: string): void;
    static reload(id: string): void;
    static updata(id: string): void;
    static setDirection(id: string, speed: number[]): boolean;
    static tagToFront(id: string, options: RotateTagType): boolean;
    static rotateTag(id: string, options: RotateTagType): boolean;
    constructor(v: ACanvasType);
    HideTags(): void;
    GetTags(): Element[];
    CreateTag(a: HTMLAnchorElement): A;
    Draw(t?: number): void;
    Transform(p: number, y: number): void;
    AnimateFixed(): boolean;
    AnimatePosition(w: number, h: number, t: number): void;
    AnimateDrag(_w: number, _h: number, t: number): void;
    Freeze(): void;
    UnFreeze(): void;
    Decel(ac: ACanvas): void;
    Zoom(r: number): void;
    Clicked(): void;
    Wheel(i: boolean): void;
    BeginDrag(e: MouseEvent | TouchEvent): void;
    Drag(p: XY): number;
    EndDrag(): number;
    PinchDistance(e: TouchEvent): number;
    BeginPinch(e: TouchEvent): void;
    Pinch(e: TouchEvent): void;
    EndPinch(): void;
    SetSpeed(i: number[]): void;
    FindTag(t: RotateTagType): A;
    RotateTag({ a, lat, lng, time, callback }: RotateTagType): void;
    Load(): void;
    Updata(): void;
    NextFrameRAF(): void;
    Smooth(t: number, t0: number): number;
}
export {};
